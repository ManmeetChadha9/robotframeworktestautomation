import collectionsimport csvimport xlrd as xlrdfrom robot.libraries.BuiltIn import BuiltInimport timeimport jsonimport pandas as pdfrom pandas import ExcelWriterimport requestsfrom selenium.webdriver.common.by import Byfrom google.cloud import storage# import openpyxl## from openpyxl import load_workbook## import xlsxwriterdef Post_File(url, headers,  kitimportfile):    payload = {}    params = {'fileName': kitimportfile}    files = {'file': open(kitimportfile, 'rb')}    response = requests.request("POST", url, headers = headers, data = payload, params = params, files = files)    print(response.text.encode('utf8'))    return response#################################################################################################################################################### Custom Keyword for writing to XL####################################################################################################################################################def Translate_Char_In_String(ini_list, Translatefrom, Translateto=None):    # Printing initial list with str    print ("List with str", str(ini_list))    translation = {int(Translatefrom): Translateto}    # Printing list using translate Method    print ("Printing list without quotes",           str(ini_list).translate(translation))    return str(ini_list).translate(translation)#################################################################################################################################################### Custom Keyword for writing to XL####################################################################################################################################################def Write_To_KitImportXL(mylist, kitimportfile):    df1 = pd.DataFrame(mylist,                       columns=['Kit ID', 'Kit Lot Number', 'Expiration Date', 'Pad 1 ID', 'Pad 1 Lot Number',  'Pad 2 ID', 'Pad 2 Lot Number',  'Product', 'Order line', 'Order', 'Customer track number', 'Laboratory track number', 'Return track number'])    df1['Expiration Date'] =  pd.to_datetime(df1['Expiration Date'], format='%d/%m/%Y').dt.date    writer = ExcelWriter(kitimportfile, engine='xlsxwriter')    df1.to_excel(writer,'Kits',index=False)    writer.save()#################################################################################################################################################### Custom Keyword for writing to XL####################################################################################################################################################def Write_To_AssayResultXL(mylist, assayresultfile):    df1 = pd.DataFrame([mylist],                       columns=['Last Name',  'First Name',  'Customer ID',  'DOB',  'Age',  'Gender',  'Kit-ID', 'Device-ID',	'Internal Lab ID',  'Day of Period',  'Collection start date',	'Collection finish date',  'Receival date',	'Assay',   'Status',  	'Analyze before',	'Date analysed',	'Time analysed',	'Specimen Type',	'Result',	'Unit',	'Failure?',	'Comment?'])    print(df1)    df1['Receival date'] =  pd.to_datetime(df1['Receival date'], format='%m/%d/%Y %I:%M:%S')    df1['Collection start date'] =  pd.to_datetime(df1['Collection start date'], format='%m/%d/%Y %I:%M:%S')    df1['Collection finish date'] =  pd.to_datetime(df1['Collection finish date'], format='%m/%d/%Y %I:%M:%S')    df1['Analyze before'] =  pd.to_datetime(df1['Analyze before'], format='%m/%d/%Y %I:%M:%S')    df1['Date analysed'] =  pd.to_datetime(df1['Date analysed'], format='%m/%d/%Y').dt.date    print(df1)    writer = ExcelWriter(assayresultfile, engine='xlsxwriter')    df1.to_excel(writer,'Results',index=False)    writer.save()#################################################################################################################################################### Custom Keyword for Reading XL####################################################################################################################################################def Read_XL(file, Pad_ID):    df = pd.read_excel(file)    print(df)    for n in df['Device-ID']:        if n == Pad_ID:            return "true"        else:            return "false"#################################################################################################################################################### Custom Keyword for getting text from XL####################################################################################################################################################def Fetch_XL(file, Column):    df = pd.read_excel(file)    print(df)    for n in df[(Column)]:        if n != None:            return n        else:            return "false"##################################################################################################################################################### Custom Keyword for sending keyboard input####################################################################################################################################################def Send_KeyBoard_Input(locatortype, locator, inputText):    browser = BuiltIn().get_library_instance('SeleniumLibrary').driver    time.sleep(2)    if ((locatortype) == 'xpath'):        browser.find_element_by_xpath(locator).send_keys(inputText)    elif ((locatortype) == 'id'):        browser.find_element_by_id(locator).send_keys(inputText)##################################################################################################################################################### Custom Keyword for clicking on a particular col/row, in a table####################################################################################################################################################def Get_Table_Column_Row_Locator(locator_type, table_locator_value, element_locator_value, input_column, lookUpText1, lookUpText2 = None):    browser = BuiltIn().get_library_instance('SeleniumLibrary').driver    time.sleep(6)    table = browser.find_element(By.XPATH, table_locator_value)    print(BuiltIn().get_library_instance('SeleniumLibrary').driver.session_id)    tr_row = 0    td_col = 0    tq_col = 0    text_found = 'N'    for tr in table.find_elements(By.TAG_NAME, 'tr'):        tr_row = tr_row + 1        td_col = 0        print("Inside first for loop")        for td in tr.find_elements(By.TAG_NAME, 'td'):            print("Inside second for loop -1")            print(td.text)            print("Inside second for loop -2")            td_col = td_col + 1            if ((td.text) == lookUpText1):                print("Inside second for loop -3")                print(tr_row)                print("Inside second for loop -4")                print(td_col)                print("Inside second for loop -5")                #text_found = 'Y'                # break                if lookUpText2 is not None:                    text_found = 'N'                    for tq in tr.find_elements(By.TAG_NAME, 'td'):                        print("Inside third for loop-1")                        print(tq.text)                        print("Inside third for loop-2")                        #tq_col = tq_col + 1                        if ((tq.text) == lookUpText2):                            text_found = 'Y'                            break                    if (text_found == 'Y'):                        break                else:                    text_found = 'Y'                    break            # if (text_found = 'Y'):            #         break        if (text_found == 'Y'):            break    tr_row = tr_row - 1    # Generating the xpath for the cell in the table    if (input_column == 'NotApplicable'):        str_cell_xpath = "/tbody/tr[" + str(tr_row) + "]/th"    else:        str_cell_xpath = "/tbody/tr[" + str(tr_row) + "]/td[" + str(input_column) + "]"    if (element_locator_value == 'NotApplicable'):        str_xpath = table_locator_value + str_cell_xpath    else:        str_xpath = table_locator_value + str_cell_xpath + element_locator_value    if (text_found == 'N'):        str_xpath = 'Text not found'        print(str_xpath)    return str_xpath##############################################################################################################Custom Keyword to Get index of any character in a string#######################################################################################################################def Get_character_index_in_string(string,  character):    start = 0    end = 0    while start < len(string):        if string[start+end] != character[end]:            start += 1            end = 0            continue        end += 1        if end == len(character):            return start + 1        return -1def Convert_Dict_To_Json(dict):    data= json.dumps(dict)    str= json.dumps(data)    js= json.loads(str)    return strdef read_csv_file(filename):    data = []    # ifile  =    with open(filename, "rt") as csvfile:        reader = csv.reader(csvfile)        for row in reader:            data.append(row)    return datadef convert_excelworkSheet_to_csv(File, sheetName):    inputFile = File    df = pd.read_excel(inputFile, sheet_name=sheetName)    df.to_csv("csv_file.csv", index=None, header=True)    return "csv_file.csv"def search_cell(File,search_string):    inputFile = File    with open(File) as ip:        reader = csv.reader(ip)        # reader =  pd.read_excel(sheet)        for i, row in enumerate(reader):            for j, column in enumerate(row):                if search_string in column:                    search_position=  {"row" : i, "column": j};        return search_positiondef fetching_excel_from_cloud(bucket_name, file_name, output_file, private_key):    client = storage.Client.from_service_account_json(json_credentials_path=private_key)    bucket = storage.Bucket(client, bucket_name)    file = bucket.blob(file_name)    file.download_to_filename(output_file)    return output_filedef post_request_with_error_handling(url, endpoint, headers, json):    try:        response = requests.post(f"{url}{endpoint}", headers=headers, json=json)        return response.json(), response.status_code    except requests.exceptions.RequestException as e:        print(f"Request failed: {e}")        return None, None